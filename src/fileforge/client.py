# This file was auto-generated by Fern from our API Definition.

import json
import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from . import core
from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.pydantic_utilities import pydantic_v1
from .core.query_encoder import encode_query
from .core.remove_none_from_dict import remove_none_from_dict
from .core.request_options import RequestOptions
from .environment import FileforgeEnvironment
from .errors.bad_gateway_error import BadGatewayError
from .errors.bad_request_error import BadRequestError
from .errors.internal_server_error import InternalServerError
from .errors.unauthorized_error import UnauthorizedError
from .types.convert_docx_request_options import ConvertDocxRequestOptions
from .types.error_schema import ErrorSchema
from .types.generate_request_options import GenerateRequestOptions
from .types.merge_request_options import MergeRequestOptions

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)

import httpx
from typing import Optional, Any, Union, Iterator

class CustomResponse:

    def __init__(self, response: httpx.Response, json_body: Optional[Any] = None, file: Optional[Iterator[bytes]] = None):
        self.response = response
        self.json_body = json_body
        self.file = file

    def json(self):
        if self.json_body is not None:
            return self.json_body
        return self.response.json()

    def __getattr__(self, item):
        return getattr(self.response, item)
    
class Fileforge:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : FileforgeEnvironment
        The environment to use for requests from the client. from .environment import FileforgeEnvironment



        Defaults to FileforgeEnvironment.DEFAULT



    api_key : str
    username : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    password : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests by default the timeout is 60 seconds, unless a custom httpx client is used, in which case a default is not set.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from fileforge.client import Fileforge

    client = Fileforge(
        api_key="YOUR_API_KEY",
        username="YOUR_USERNAME",
        password="YOUR_PASSWORD",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: FileforgeEnvironment = FileforgeEnvironment.DEFAULT,
        api_key: str,
        username: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        password: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = timeout if timeout is not None else 60 if httpx_client is None else None
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            api_key=api_key,
            username=username,
            password=password,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.Client(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.Client(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )

    def retrieve_server_status(self, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from fileforge.client import Fileforge

        client = Fileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        client.retrieve_server_status()
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "status/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def convert_docx(
        self,
        *,
        options: ConvertDocxRequestOptions,
        file: core.File,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Converts a Microsoft Word document (.DOCX or .DOC) file to a PDF document.

        This service uses a LibreOffice headless server to perform the conversion, and may not support all features of the original document.

        **Known discrepancies**

        - Some fonts may not be available in the server, and may be substituted by a closest match.
        - Some complex formatting may not be preserved, such as background graphics.

        **Variables**

        Variable replacement is supported with various methods:

        - Templated litterals: `{{name}}`
        - Word variables, as listed in the document metadata: `{DOCVARIABLE "name"}`

        To enable variable replacement as Word variables for your account, please contact the FileForge support.

        Parameters
        ----------
        options : ConvertDocxRequestOptions
            Conversion options. This field is required even if empty.

            **Options**

            * `templateLiterals`: Map of template literals to replace in the document. Template literals should be enclosed in double curly braces, e.g. `{{name}}`. Variables name can contain alphanumeric characters and hyphens. All variables are case-sensitive. The value for each variable should be a string. If a value of undefined is passed, the variable will not be removed from the document. If you need to remove a variable, pass an empty string as the value.

            **NB** variables should **not** have surrounding spaces, e.g. `{{ name }}`.

            **Example**

            In the Word document: `{{name}} {{nickname}}. was born on {{date}}.`

            ```json
            {
              "templateLiterals": {
                "name": "John Doe",
                "date": "2021-12-31",
                "nickname": ""
              }
            }
            ```

            There will not be an error if a variable is not found in the document, nor if variables found in the document are not in the options.

        file : core.File
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[bytes]
            PDF Document generated successfully

        Examples
        --------
        from fileforge.client import Fileforge

        client = Fileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        client.convert_docx()
        """
        with self._client_wrapper.httpx_client.stream(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "pdf/docx/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            data={}
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            files=core.convert_file_dict_to_httpx_tuples(remove_none_from_dict({
                "options": (None, json.dumps(jsonable_encoder(options)), "application/json"),
                "file": file
            })),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _chunk in _response.iter_bytes():
                    yield _chunk
                return
            _response.read()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate(
        self,
        *,
        options: GenerateRequestOptions,
        files: typing.List[core.File],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Generates a PDF document from web assets.

        Parameters
        ----------
        options : GenerateRequestOptions
            Conversion options. This field is required even if empty.

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[bytes]
            PDF Document generated successfully

        Examples
        --------
        from fileforge.client import Fileforge

        client = Fileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        client.generate()
        """
        with self._client_wrapper.httpx_client.stream(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "pdf/generate/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            data={}
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            files=core.convert_file_dict_to_httpx_tuples(remove_none_from_dict({
                "options": (None, json.dumps(jsonable_encoder(options)), "application/json"),
                "files": files
            })),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                content_type = _response.headers.get('content-type', '')
                if content_type.startswith('application/json'):
                    json_body = json.loads(_response.read())
                    return CustomResponse(_response, json_body= json_body)
                elif content_type.startswith('application/pdf'):
                    
                    return {"file": _response.iter_bytes()}
                else:
                    return CustomResponse(_response)
            
            _response.read()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 502:
                raise BadGatewayError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def merge(
        self,
        *,
        options: MergeRequestOptions,
        files: typing.List[core.File],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Parameters
        ----------
        options : MergeRequestOptions

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[bytes]
            PDF Document generated successfully

        Examples
        --------
        from fileforge.client import Fileforge

        client = Fileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        client.merge()
        """
        with self._client_wrapper.httpx_client.stream(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "pdf/merge/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            data={}
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            files=core.convert_file_dict_to_httpx_tuples(remove_none_from_dict({
                "options": (None, json.dumps(jsonable_encoder(options)), "application/json"),
                "files": files
            })),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _chunk in _response.iter_bytes():
                    yield _chunk
                return
            _response.read()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncFileforge:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : FileforgeEnvironment
        The environment to use for requests from the client. from .environment import FileforgeEnvironment



        Defaults to FileforgeEnvironment.DEFAULT



    api_key : str
    username : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    password : typing.Optional[typing.Union[str, typing.Callable[[], str]]]
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests by default the timeout is 60 seconds, unless a custom httpx client is used, in which case a default is not set.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from fileforge.client import AsyncFileforge

    client = AsyncFileforge(
        api_key="YOUR_API_KEY",
        username="YOUR_USERNAME",
        password="YOUR_PASSWORD",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: FileforgeEnvironment = FileforgeEnvironment.DEFAULT,
        api_key: str,
        username: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        password: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = timeout if timeout is not None else 60 if httpx_client is None else None
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            api_key=api_key,
            username=username,
            password=password,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )

    async def retrieve_server_status(self, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from fileforge.client import AsyncFileforge

        client = AsyncFileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        await client.retrieve_server_status()
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "status/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def convert_docx(
        self,
        *,
        options: ConvertDocxRequestOptions,
        file: core.File,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Converts a Microsoft Word document (.DOCX or .DOC) file to a PDF document.

        This service uses a LibreOffice headless server to perform the conversion, and may not support all features of the original document.

        **Known discrepancies**

        - Some fonts may not be available in the server, and may be substituted by a closest match.
        - Some complex formatting may not be preserved, such as background graphics.

        **Variables**

        Variable replacement is supported with various methods:

        - Templated litterals: `{{name}}`
        - Word variables, as listed in the document metadata: `{DOCVARIABLE "name"}`

        To enable variable replacement as Word variables for your account, please contact the FileForge support.

        Parameters
        ----------
        options : ConvertDocxRequestOptions
            Conversion options. This field is required even if empty.

            **Options**

            * `templateLiterals`: Map of template literals to replace in the document. Template literals should be enclosed in double curly braces, e.g. `{{name}}`. Variables name can contain alphanumeric characters and hyphens. All variables are case-sensitive. The value for each variable should be a string. If a value of undefined is passed, the variable will not be removed from the document. If you need to remove a variable, pass an empty string as the value.

            **NB** variables should **not** have surrounding spaces, e.g. `{{ name }}`.

            **Example**

            In the Word document: `{{name}} {{nickname}}. was born on {{date}}.`

            ```json
            {
              "templateLiterals": {
                "name": "John Doe",
                "date": "2021-12-31",
                "nickname": ""
              }
            }
            ```

            There will not be an error if a variable is not found in the document, nor if variables found in the document are not in the options.

        file : core.File
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[bytes]
            PDF Document generated successfully

        Examples
        --------
        from fileforge.client import AsyncFileforge

        client = AsyncFileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        await client.convert_docx()
        """
        async with self._client_wrapper.httpx_client.stream(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "pdf/docx/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            data={}
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            files=core.convert_file_dict_to_httpx_tuples(remove_none_from_dict({
                "options": (None, json.dumps(jsonable_encoder(options)), "application/json"),
                "file": file
            })),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _chunk in _response.aiter_bytes():
                    yield _chunk
                return
            await _response.aread()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate(
        self,
        *,
        options: GenerateRequestOptions,
        files: typing.List[core.File],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Generates a PDF document from web assets.

        Parameters
        ----------
        options : GenerateRequestOptions
            Conversion options. This field is required even if empty.

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[bytes]
            PDF Document generated successfully

        Examples
        --------
        from fileforge.client import AsyncFileforge

        client = AsyncFileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        await client.generate()
        """
        async with self._client_wrapper.httpx_client.stream(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "pdf/generate/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            data={}
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            files=core.convert_file_dict_to_httpx_tuples(remove_none_from_dict({
                "options": (None, json.dumps(jsonable_encoder(options)), "application/json"),
                "files": files
            })),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _chunk in _response.aiter_bytes():
                    yield _chunk
                return
            await _response.aread()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 502:
                raise BadGatewayError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def merge(
        self,
        *,
        options: MergeRequestOptions,
        files: typing.List[core.File],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Parameters
        ----------
        options : MergeRequestOptions

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[bytes]
            PDF Document generated successfully

        Examples
        --------
        from fileforge.client import AsyncFileforge

        client = AsyncFileforge(
            api_key="YOUR_API_KEY",
            username="YOUR_USERNAME",
            password="YOUR_PASSWORD",
        )
        await client.merge()
        """
        async with self._client_wrapper.httpx_client.stream(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "pdf/merge/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            data={}
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            files=core.convert_file_dict_to_httpx_tuples(remove_none_from_dict({
                "options": (None, json.dumps(jsonable_encoder(options)), "application/json"),
                "files": files
            })),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _chunk in _response.aiter_bytes():
                    yield _chunk
                return
            await _response.aread()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorSchema, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: FileforgeEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
